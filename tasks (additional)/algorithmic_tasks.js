// Реалізувати алгоритм бінарного пошуку

// Бінарний пошук - це алгоритм, що слідує парадигмі "розділяй і володарюй": завдання розбивається на підзавдання.
// Цей алгоритм пошуку зручний, якщо потрібно знайти число в масиві простих чисел або елемент у списку. Найпростіший
// спосіб вирішення - за допомогою рекурсії.

// Важливо: бінарний пошук можливий, тільки якщо масив даних відсортовано.

// Часова складність O(log n).
(function () {
  // Method 1
  // function binarySearch(value, list) {
  //   let first = 0; // left endpoint
  //   let last = list.length - 1; // right endpoint
  //   let position = -1;
  //   let found = false;
  //   let middle;
  //
  //   while (found === false && first <= last) {
  //     middle = Math.floor((first + last) / 2);
  //
  //     if (list[middle] == value) {
  //       found = true;
  //       position = middle;
  //     } else if (list[middle] > value) { // if in lower half
  //       last = middle - 1;
  //     } else { // in upper half
  //       first = middle + 1;
  //     }
  //   }
  //
  //   return position;
  // }
  //
  // console.log('Index: ', binarySearch(8, [1, 2, 3, 4, 5, 6, 7, 8, 9]));

  // Method 2
  let binarySearch = function(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    let mid;

    while (left <= right) {
      mid = Math.round((right - left) / 2) + left;

      if (target === nums[mid]) {
        return mid;
      } else if (target < nums[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }

    return -1;
  }

  console.log('Index: ', binarySearch([-1, 0, 3, 5, 7, 9, 12], 9));
});



// Реалізуйте сортування бульбашкою

// Під час сортування бульбашкою порівнюють числа, що стоять поряд, вибудовуючи їх у порядку
// убування або зростання.

// Тимчасова складність - O(n²), через що алгоритм підходить тільки для невеликого обсягу даних.
(function () {
  const bubbleSort = arr => {
    for (let i = 0, endI = arr.length - 1; i < endI; i++) {
      let wasSwap = false;

      for (let j = 0, endJ = endI - i; j < endJ; j++) {
        if (arr[j] > arr[j + 1]) {
          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];

          wasSwap = true;
        }
      }

      if (!wasSwap) break;
    }

    return arr;
  };

  console.log(bubbleSort([-1, 4, 7, 2, 1, 5, -3, 3]));
});



// Як реалізувати алгоритм сортування вставкою?

// Принцип схожий із сортуванням колоди або одягу в шафі. Кожна карта лягає на своє місце, інакше
// кажучи, кожен наступний елемент додається на певну позицію.

// Часова складність O(n), в найгіршому випадку O(n^2).
(function () {
  const insertionSort = arr => {
    for (let i = 1, l = arr.length; i < l; i++) {
      const current = arr[i];
      let j = i;

      while (j > 0 && arr[j - 1] > current) {
        arr[j] = arr[j - 1];
        j--;
      }

      arr[j] = current;
    }

    return arr;
  };

  console.log(insertionSort([7, 4, 3, 9, 2]));
});



// Як реалізувати сортування злиттям?

// Як у випадку зі швидким сортуванням, цей метод відносять до групи "розділяй і володарюй". Наприклад,
// щоб відсортувати масив чисел, ви його розділите на невеликі частини, поки не залишиться масив в один
// або нуль відсортованих елементів. Далі слід об'єднати малі масиви, щоб отримати фінальний результат.

// Часова складність O(n log n), але при цьому він долучає O(n) додаткової пам'яті.
(function () {
  const merge = (arrFirst, arrSecond) => {
    const arrSort = [];
    let i = j = 0;

    // Порівнюємо два масиви, по черзі зсуваючи покажчики
    while (i < arrFirst.length && j < arrSecond.length) {
      arrSort.push(
        (arrFirst[i] < arrSecond[j]) ?
          arrFirst[i++] : arrSecond[j++]
      );
    }
    // Обробляємо останній елемент за різної довжини масивів і повертаємо один відсортований масив
    return [
      ...arrSort,
      ...arrFirst.slice(i),
      ...arrSecond.slice(j)
    ];
  };

  const mergeSort = arr => {
    // Перевіряємо коректність переданих даних
    if (!arr || !arr.length) {
      return null;
    }

    // Якщо масив містить один елемент просто повертаємо його
    if (arr.length <= 1) {
      return arr;
    }

    // Знаходимо середину масиву і ділимо його на два
    const middle = Math.floor(arr.length / 2);
    const arrLeft = arr.slice(0, middle);
    const arrRight = arr.slice(middle);

    // Для нових масивів знову викликаємо сортування, зливаємо їх і повертаємо знову єдиний масив
    return merge(mergeSort(arrLeft), mergeSort(arrRight));
  };

  console.log(mergeSort([-1, 4, 7, 2, 1, 5, -3, 3]));
});



// Реалізуйте алгоритм швидкого сортування.

// Алгоритм належить до групи "розділяй і володарюй", що зумовлює поділ задачі на підзадачі. Тобто,
// спочатку потрібно розбити наявні дані на найдрібніші складові, масиви з одного елемента
// (або з нульовою кількістю елементів).

// Часова складність найгіршого варіанту O(n^2), а середнього O(n log n).
(function () {
  const quickSort = (arr) => {
    if (arr.length <= 1) {
      return arr;
    }

    let pivot = arr[arr.length - 1];
    let leftArr = [];
    let rightArr = [];

    for (let i = 1; i < arr.length; i++) {
      if (arr[i] < pivot) {
        leftArr.push(arr[i]);
      } else {
        rightArr.push(arr[i]);
      }
    }

    return [...quickSort(leftArr), pivot, ...quickSort(rightArr)];
  };
});



// Знайдіть будь-яке число, що повторюється
// Дано: масив з N+1 цілих чисел, який містить елементи в діапазоні [1, N].

// Часова складність O(N), просторова складність O(1), масив незмінний.
(function () {
  // Алгоритм Флойда пошуку циклу - це алгоритм покажчиків, який використовує лише два покажчики, що
  // пересуваються вздовж послідовності з різними швидкостями. Алгоритм називається також алгоритмом
  // "черепахи та зайця".
  const findAnyRepeatedNumber = (arr = []) => {
    let slow = arr[0];
    let fast = arr[0];

    do {
      slow = arr[slow];
      fast = arr[arr[fast]];
    } while(slow !== fast);

    slow = arr[0];

    while (slow !== fast) {
      slow = arr[slow];
      fast = arr[fast];
    }

    return fast;
  }

  console.log(findAnyRepeatedNumber([2, 6, 4, 1, 3, 1, 5])); // 1
});



// Алгоритмічна задача про острови
// Для двовимірного масиву M x N, що складається з одиниць, які позначають суходіл, і нулів, які
// позначають воду, поверніть кількість островів.
// Острів оточений водою й утворений з'єднанням сусідніх земель по горизонталі та вертикалі. Ви можете
// припустити, що всі чотири краї матриці оточені водою.
// Примітка Якщо островів немає, повертаємо 0.
(function () {
  // Розв'язання
  // Для початку нам потрібно знайти в матриці хоча б одну одиницю: починаємо рядковий обхід з нульового
  // індексу [0,0]. Коли ми знаходимо одиницю, позначаємо її, як переглянуту, і також переглядаємо
  // сусідні клітинки за напрямками вправо, вниз, вліво, вгору.
  // Якщо попередня клітинка була суходолом, а наступна виявилася водою, ми повертаємося до суходолу
  // і переглядаємо клітинки за переліченими напрямками в тому ж порядку.

  // Метод обходу острова: приймає матрицю і координати
  const markIsland = (matrix, i, j) => {
    // Умова виходу за край матриці
    if (i < 0 || i >= matrix.length || j < 0 || j >= matrix[i].length || matrix[i][j] === '0')
      return;

    // Якщо не вийшли за кордон, позначаємо клітинку як 0
    matrix[i][j] = '0';

    // Оглядаємося:
    markIsland(matrix, i, j + 1); // вправо
    markIsland(matrix, i + 1, j); // вниз
    markIsland(matrix, i, j - 1); // вліво
    markIsland(matrix, i - 1, j); // вверх
  }

  // Метод приймає 2-вимірний масив символів
  const howMuchLands = (matrix) => {
    // Перевіряємо величину масиву
    if (matrix == null || matrix.length === 0)
      return 0;

    // Змінна, що зберігає кількість островів
    let numIslands = 0;

    // Починаємо обхід із верхнього лівого кута (перебір рядків):
    for (let i = 0; i < matrix.length; i++) {
      // Перебір стовпців
      for (let j = 0; j < matrix[i].length; j++){
        // Якщо 1,
        if(matrix[i][j] === '1'){
          // збільшуємо кількість островів
          numIslands++;
          // і проходимо по периметру
          markIsland(matrix, i, j);
        }
      }
    }

    return numIslands;
  }

  const lands = howMuchLands([
    ['0', '0', '0', '0', '0', '0', '0', '0', '0'],
    ['0', '0', '0', '0', '0', '0', '0', '0', '0'],
    ['0', '0', '1', '1', '0', '0', '0', '0', '0'],
    ['0', '0', '1', '0', '0', '0', '0', '0', '0'],
    ['0', '0', '0', '0', '0', '0', '0', '0', '0'],
    ['0', '0', '0', '0', '0', '0', '0', '0', '0'],
    ['0', '0', '0', '0', '1', '1', '1', '0', '0'],
    ['0', '0', '0', '0', '0', '0', '0', '0', '0'],
    ['1', '0', '0', '0', '0', '0', '0', '0', '0'],
  ]);

  console.log(lands);
});



// Пошук знаменитості

// Дано групу людей з K осіб, і ці люди можуть знати одне одного, необов'язково взаємно. Серед
// них є знаменитість. Знаменитість - це людина, яка не знає нікого в компанії, натомість кожен
// із компанії знає її. Спочатку ми не володіємо інформацією про те, хто кого знає, але ми можемо
// запитати в кожного учасника, чи знає він інших людей із групи. Потрібно визначити знаменитість,
// використовуючи мінімальну кількість запитань.
(function () {
  // Розв'язання
  // Для початку визначимося з тим, що знаменитість лише одна. Щоб зрозуміти наступний алгоритм
  // розв'язання, подивимося на двох людей із групи. Позначимо їх як A і B.

  // Коли ми запитуємо в A, чи знає він B, ми отримуємо два варіанти відповіді:
  // Знає - людина A не знаменитість.
  // Не знає - людина B не знаменитість.

  // Так, поставивши лише одне запитання, ми позбуваємося одного кандидата на статус знаменитості.
  // Саме цей алгоритм ми й використовуємо в програмі: опитується кілька людей, після чого одна з
  // них викреслюється зі списку, і так поки не залишиться один кандидат.

  // Але наявність одного кандидата ще не означає, що він знаменитість, адже її може не бути зовсім.
  // Тому останні дві дії полягають у тому, щоб запитати в інших, чи знають вони кандидата, а в
  // кандидата - чи знає він усіх інших.

  // Функція, яка приймає масив і повертає один елемент або null
  const findCelebrity = (persons = []) => {
    // Використовуємо метод двох покажчиків: початок масиву і кінець масиву
    let l = 0, r = persons.length - 1;

    // Рухаємося від початку і кінця до середини масиву
    while (l !== r){
      if (persons[l].knows(persons[r])) { l++; }
      else { r--; }
    }

    // Коли залишається один кандидат, проходимо по всьому масиву
    for (let i = 0; i < persons.length; i++) {
      // Перевіряємо, що кандидат не знаменитість із такими умовами
      if (i !== l && (!persons[i].knows(persons[l]) || persons[l].knows(persons[i]))) {
        return null;
      }
    }

    // Якщо кандидат пройшов перевірки, повертаємо його як відповідь
    return persons[l];
  }

  const celebrity = findCelebrity([
    { name: 'Anna', knows: (person) => ['Bob', 'Dog'].includes(person.name) },
    { name: 'Bob', knows: (person) => ['Bob', 'Dog'].includes(person.name) },
    { name: 'Dog', knows: (person) => [''].includes(person.name) },
  ]);

  console.log(celebrity);
});



// Сума чисел

// Дано відсортований масив чисел, включно з від'ємними, і деяке число K. Потрібно знайти два числа
// з масиву, які в сумі дадуть число K. Якщо таких чисел немає, у результаті повертаємо порожній
// масив. Якщо комбінацій чисел, що дають потрібну суму, кілька, повертаємо будь-яку з них.

// Є кілька варіантів розв'язання задачі:
// перебір усіх пар - часова складність алгоритму O(n²);
// HashSet - O(n);
// бінарний пошук - O(n log n);
// два покажчики - O(n).

// Розв'яжемо задачу за допомогою HashSet.
// Хоч метод HashSet і працює за один прохід масивом, він витрачає додаткову пам'ять, тому що в
// найгіршому випадку ми перенесемо всі елементи з вхідного масиву в наш сет.
(function () {
  // Рішення
  // Створюємо порожній сет і дивимося перший елемент масиву. Додаємо його в сет. Далі дивимося
  // другий елемент і те, чи дає він у сумі з винесеним у сет першим елементом K. Якщо ні, просто
  // переносимо його в сет. Так ми продовжуємо доти, доки не знайдемо число, яке в сумі з іншим
  // числом із сету дасть число K. Виводимо масив із цих двох елементів як відповідь.

  // Функція приймає масив чисел, число k і повертає масив чисел
  function sumK(numbers, k) {
    // Створюємо порожній сет
    let numSet = new Set();

    // Йдемо по масиву зліва направо
    for (let i = 0; i < numbers.length; i++) {
      // Визначаємо, яким має бути друге число з пари
      let secondNumber = k - numbers[i];

      // Перевіряємо, чи зустрічалося нам це число раніше
      if (numSet.has(secondNumber)) {
        // Повертаємо новий масив
        return [secondNumber, numbers[i]];
      }

      // Якщо не зустрічалося, просто додаємо число в наш сет
      numSet.add(numbers[i]);
    }

    // Якщо відповіді немає, повертаємо порожній масив
    return [];
  }
});



// Теплі дні: завдання на стек

// Дано масив чисел, що складається з N елементів. Ці числа позначають температуру в конкретний день.
// Для кожного дня потрібно знайти кількість діб до настання більш теплого дня.

// Ось приклад того, як це можна зобразити:
// // Температура:
// 17 16 19 15 13 18 20
// // Кількість діб до більш теплого дня:
// 2 1 4 2 1 1 0
(function () {
  // Рішення
  // Використаємо два цикли. У першому ми будемо йти всіма днями, для яких хочемо визначити відповідь,
  // а в другому пробігати праворуч доти, доки не натрапимо на тепліший день.

  // Метод, що приймає масив температур
  function dailyTemperatures(temperatures) {
    const n = temperatures.length;

    // Масив відповідей за довжиною дорівнює масиву температур
    const answer = new Array(n).fill(0);

    // Йдемо по днях, для яких шукаємо відповідь
    for (let day = 0; day < n; day++) {
      // Йдемо по днях, для яких шукаємо відповідь
      for (let futureDay = day + 1; futureDay < n; futureDay++) {
        // Якщо температура наступного дня більша за поточну,
        if (temperatures[futureDay] > temperatures[day]) {
          // проставляємо відповідь
          answer[day] = futureDay - day;
          break;
        }
      }
    }

    return answer;
  }

  console.log(dailyTemperatures([17, 16, 19, 15, 13, 18, 20]));
});



// ...
(function () {

})();
